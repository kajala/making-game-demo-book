<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Engine Core: odemath.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040824 -->
<div class="qindex"><a class="qindex" href="../../index.html">Main&nbsp;Page</a> | <a class="qindex" href="../../modules.html">Modules</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a></div>
<h1>odemath.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment"> *                                                                       *</span>
00003 <span class="comment"> * Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.       *</span>
00004 <span class="comment"> * All rights reserved.  Email: russ@q12.org   Web: www.q12.org          *</span>
00005 <span class="comment"> *                                                                       *</span>
00006 <span class="comment"> * This library is free software; you can redistribute it and/or         *</span>
00007 <span class="comment"> * modify it under the terms of EITHER:                                  *</span>
00008 <span class="comment"> *   (1) The GNU Lesser General Public License as published by the Free  *</span>
00009 <span class="comment"> *       Software Foundation; either version 2.1 of the License, or (at  *</span>
00010 <span class="comment"> *       your option) any later version. The text of the GNU Lesser      *</span>
00011 <span class="comment"> *       General Public License is included with this library in the     *</span>
00012 <span class="comment"> *       file LICENSE.TXT.                                               *</span>
00013 <span class="comment"> *   (2) The BSD-style license that is included with this library in     *</span>
00014 <span class="comment"> *       the file LICENSE-BSD.TXT.                                       *</span>
00015 <span class="comment"> *                                                                       *</span>
00016 <span class="comment"> * This library is distributed in the hope that it will be useful,       *</span>
00017 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
00018 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *</span>
00019 <span class="comment"> * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *</span>
00020 <span class="comment"> *                                                                       *</span>
00021 <span class="comment"> *************************************************************************/</span>
00022 
00023 <span class="preprocessor">#ifndef _ODE_ODEMATH_H_</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define _ODE_ODEMATH_H_</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include &lt;ode/common.h&gt;</span>
00027 
00028 <span class="preprocessor">#ifdef __GNUC__</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define PURE_INLINE extern inline</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define PURE_INLINE inline</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="comment">/*</span>
00035 <span class="comment"> * macro to access elements i,j in an NxM matrix A, independent of the</span>
00036 <span class="comment"> * matrix storage convention.</span>
00037 <span class="comment"> */</span>
00038 <span class="preprocessor">#define dACCESS33(A,i,j) ((A)[(i)*4+(j)])</span>
00039 <span class="preprocessor"></span>
00040 
00041 <span class="comment">/*</span>
00042 <span class="comment"> * 3-way dot product. dDOTpq means that elements of `a' and `b' are spaced</span>
00043 <span class="comment"> * p and q indexes apart respectively. dDOT() means dDOT11.</span>
00044 <span class="comment"> * in C++ we could use function templates to get all the versions of these</span>
00045 <span class="comment"> * functions - but on some compilers this will result in sub-optimal code.</span>
00046 <span class="comment"> */</span>
00047 
00048 <span class="preprocessor">#define dDOTpq(a,b,p,q) ((a)[0]*(b)[0] + (a)[p]*(b)[q] + (a)[2*(p)]*(b)[2*(q)])</span>
00049 <span class="preprocessor"></span>
00050 <span class="preprocessor">#ifdef __cplusplus</span>
00051 <span class="preprocessor"></span>
00052 PURE_INLINE dReal dDOT   (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,1,1); }
00053 PURE_INLINE dReal dDOT13 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,1,3); }
00054 PURE_INLINE dReal dDOT31 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,3,1); }
00055 PURE_INLINE dReal dDOT33 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,3,3); }
00056 PURE_INLINE dReal dDOT14 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,1,4); }
00057 PURE_INLINE dReal dDOT41 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,4,1); }
00058 PURE_INLINE dReal dDOT44 (<span class="keyword">const</span> dReal *a, <span class="keyword">const</span> dReal *b) { <span class="keywordflow">return</span> dDOTpq(a,b,4,4); }
00059 
00060 <span class="preprocessor">#else</span>
00061 <span class="preprocessor"></span>
00062 <span class="preprocessor">#define dDOT(a,b)   dDOTpq(a,b,1,1)</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#define dDOT13(a,b) dDOTpq(a,b,1,3)</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#define dDOT31(a,b) dDOTpq(a,b,3,1)</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#define dDOT33(a,b) dDOTpq(a,b,3,3)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define dDOT14(a,b) dDOTpq(a,b,1,4)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define dDOT41(a,b) dDOTpq(a,b,4,1)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define dDOT44(a,b) dDOTpq(a,b,4,4)</span>
00069 <span class="preprocessor"></span>
00070 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00071 
00072 
00073 <span class="comment">/*</span>
00074 <span class="comment"> * cross product, set a = b x c. dCROSSpqr means that elements of `a', `b'</span>
00075 <span class="comment"> * and `c' are spaced p, q and r indexes apart respectively.</span>
00076 <span class="comment"> * dCROSS() means dCROSS111. `op' is normally `=', but you can set it to</span>
00077 <span class="comment"> * +=, -= etc to get other effects.</span>
00078 <span class="comment"> */</span>
00079 
00080 <span class="preprocessor">#define dCROSS(a,op,b,c) \</span>
00081 <span class="preprocessor">  (a)[0] op ((b)[1]*(c)[2] - (b)[2]*(c)[1]); \</span>
00082 <span class="preprocessor">  (a)[1] op ((b)[2]*(c)[0] - (b)[0]*(c)[2]); \</span>
00083 <span class="preprocessor">  (a)[2] op ((b)[0]*(c)[1] - (b)[1]*(c)[0]);</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define dCROSSpqr(a,op,b,c,p,q,r) \</span>
00085 <span class="preprocessor">  (a)[  0] op ((b)[  q]*(c)[2*r] - (b)[2*q]*(c)[  r]); \</span>
00086 <span class="preprocessor">  (a)[  p] op ((b)[2*q]*(c)[  0] - (b)[  0]*(c)[2*r]); \</span>
00087 <span class="preprocessor">  (a)[2*p] op ((b)[  0]*(c)[  r] - (b)[  q]*(c)[  0]);</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS114(a,op,b,c) dCROSSpqr(a,op,b,c,1,1,4)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS141(a,op,b,c) dCROSSpqr(a,op,b,c,1,4,1)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS144(a,op,b,c) dCROSSpqr(a,op,b,c,1,4,4)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS411(a,op,b,c) dCROSSpqr(a,op,b,c,4,1,1)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS414(a,op,b,c) dCROSSpqr(a,op,b,c,4,1,4)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS441(a,op,b,c) dCROSSpqr(a,op,b,c,4,4,1)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define dCROSS444(a,op,b,c) dCROSSpqr(a,op,b,c,4,4,4)</span>
00095 <span class="preprocessor"></span>
00096 
00097 <span class="comment">/*</span>
00098 <span class="comment"> * set a 3x3 submatrix of A to a matrix such that submatrix(A)*b = a x b.</span>
00099 <span class="comment"> * A is stored by rows, and has `skip' elements per row. the matrix is</span>
00100 <span class="comment"> * assumed to be already zero, so this does not write zero elements!</span>
00101 <span class="comment"> * if (plus,minus) is (+,-) then a positive version will be written.</span>
00102 <span class="comment"> * if (plus,minus) is (-,+) then a negative version will be written.</span>
00103 <span class="comment"> */</span>
00104 
00105 <span class="preprocessor">#define dCROSSMAT(A,a,skip,plus,minus) \</span>
00106 <span class="preprocessor">  (A)[1] = minus (a)[2]; \</span>
00107 <span class="preprocessor">  (A)[2] = plus (a)[1]; \</span>
00108 <span class="preprocessor">  (A)[(skip)+0] = plus (a)[2]; \</span>
00109 <span class="preprocessor">  (A)[(skip)+2] = minus (a)[0]; \</span>
00110 <span class="preprocessor">  (A)[2*(skip)+0] = minus (a)[1]; \</span>
00111 <span class="preprocessor">  (A)[2*(skip)+1] = plus (a)[0];</span>
00112 <span class="preprocessor"></span>
00113 
00114 <span class="comment">/*</span>
00115 <span class="comment"> * compute the distance between two 3-vectors</span>
00116 <span class="comment"> */</span>
00117 
00118 <span class="preprocessor">#ifdef __cplusplus</span>
00119 <span class="preprocessor"></span>PURE_INLINE <span class="keywordtype">float</span> dDISTANCE (<span class="keyword">const</span> <span class="keywordtype">float</span> a[3], <span class="keyword">const</span> <span class="keywordtype">float</span> b[3])
00120     { <span class="keywordflow">return</span> (float) dSqrt( (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]) ); }
00121 PURE_INLINE <span class="keywordtype">double</span> dDISTANCE (<span class="keyword">const</span> <span class="keywordtype">double</span> a[3], <span class="keyword">const</span> <span class="keywordtype">double</span> b[3])
00122     { <span class="keywordflow">return</span> dSqrt( (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]) ); }
00123 <span class="preprocessor">#else</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define dDISTANCE(a,b) \</span>
00125 <span class="preprocessor">    (dSqrt( ((a)[0]-(b)[0])*((a)[0]-(b)[0]) + ((a)[1]-(b)[1])*((a)[1]-(b)[1]) + ((a)[2]-(b)[2])*((a)[2]-(b)[2]) ))</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00127 <span class="preprocessor"></span>
00128 
00129 <span class="comment">/*</span>
00130 <span class="comment"> * special case matrix multipication, with operator selection</span>
00131 <span class="comment"> */</span>
00132 
00133 <span class="preprocessor">#define dMULTIPLYOP0_331(A,op,B,C) \</span>
00134 <span class="preprocessor">  (A)[0] op dDOT((B),(C)); \</span>
00135 <span class="preprocessor">  (A)[1] op dDOT((B+4),(C)); \</span>
00136 <span class="preprocessor">  (A)[2] op dDOT((B+8),(C));</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYOP1_331(A,op,B,C) \</span>
00138 <span class="preprocessor">  (A)[0] op dDOT41((B),(C)); \</span>
00139 <span class="preprocessor">  (A)[1] op dDOT41((B+1),(C)); \</span>
00140 <span class="preprocessor">  (A)[2] op dDOT41((B+2),(C));</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYOP0_133(A,op,B,C) \</span>
00142 <span class="preprocessor">  (A)[0] op dDOT14((B),(C)); \</span>
00143 <span class="preprocessor">  (A)[1] op dDOT14((B),(C+1)); \</span>
00144 <span class="preprocessor">  (A)[2] op dDOT14((B),(C+2));</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYOP0_333(A,op,B,C) \</span>
00146 <span class="preprocessor">  (A)[0] op dDOT14((B),(C)); \</span>
00147 <span class="preprocessor">  (A)[1] op dDOT14((B),(C+1)); \</span>
00148 <span class="preprocessor">  (A)[2] op dDOT14((B),(C+2)); \</span>
00149 <span class="preprocessor">  (A)[4] op dDOT14((B+4),(C)); \</span>
00150 <span class="preprocessor">  (A)[5] op dDOT14((B+4),(C+1)); \</span>
00151 <span class="preprocessor">  (A)[6] op dDOT14((B+4),(C+2)); \</span>
00152 <span class="preprocessor">  (A)[8] op dDOT14((B+8),(C)); \</span>
00153 <span class="preprocessor">  (A)[9] op dDOT14((B+8),(C+1)); \</span>
00154 <span class="preprocessor">  (A)[10] op dDOT14((B+8),(C+2));</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYOP1_333(A,op,B,C) \</span>
00156 <span class="preprocessor">  (A)[0] op dDOT44((B),(C)); \</span>
00157 <span class="preprocessor">  (A)[1] op dDOT44((B),(C+1)); \</span>
00158 <span class="preprocessor">  (A)[2] op dDOT44((B),(C+2)); \</span>
00159 <span class="preprocessor">  (A)[4] op dDOT44((B+1),(C)); \</span>
00160 <span class="preprocessor">  (A)[5] op dDOT44((B+1),(C+1)); \</span>
00161 <span class="preprocessor">  (A)[6] op dDOT44((B+1),(C+2)); \</span>
00162 <span class="preprocessor">  (A)[8] op dDOT44((B+2),(C)); \</span>
00163 <span class="preprocessor">  (A)[9] op dDOT44((B+2),(C+1)); \</span>
00164 <span class="preprocessor">  (A)[10] op dDOT44((B+2),(C+2));</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYOP2_333(A,op,B,C) \</span>
00166 <span class="preprocessor">  (A)[0] op dDOT((B),(C)); \</span>
00167 <span class="preprocessor">  (A)[1] op dDOT((B),(C+4)); \</span>
00168 <span class="preprocessor">  (A)[2] op dDOT((B),(C+8)); \</span>
00169 <span class="preprocessor">  (A)[4] op dDOT((B+4),(C)); \</span>
00170 <span class="preprocessor">  (A)[5] op dDOT((B+4),(C+4)); \</span>
00171 <span class="preprocessor">  (A)[6] op dDOT((B+4),(C+8)); \</span>
00172 <span class="preprocessor">  (A)[8] op dDOT((B+8),(C)); \</span>
00173 <span class="preprocessor">  (A)[9] op dDOT((B+8),(C+4)); \</span>
00174 <span class="preprocessor">  (A)[10] op dDOT((B+8),(C+8));</span>
00175 <span class="preprocessor"></span>
00176 <span class="preprocessor">#ifdef __cplusplus</span>
00177 <span class="preprocessor"></span>
00178 <span class="preprocessor">#define DECL template &lt;class TA, class TB, class TC&gt; PURE_INLINE void</span>
00179 <span class="preprocessor"></span>
00180 DECL dMULTIPLY0_331(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_331(A,=,B,C) }
00181 DECL dMULTIPLY1_331(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP1_331(A,=,B,C) }
00182 DECL dMULTIPLY0_133(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_133(A,=,B,C) }
00183 DECL dMULTIPLY0_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_333(A,=,B,C) }
00184 DECL dMULTIPLY1_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP1_333(A,=,B,C) }
00185 DECL dMULTIPLY2_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP2_333(A,=,B,C) }
00186 
00187 DECL dMULTIPLYADD0_331(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_331(A,+=,B,C) }
00188 DECL dMULTIPLYADD1_331(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP1_331(A,+=,B,C) }
00189 DECL dMULTIPLYADD0_133(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_133(A,+=,B,C) }
00190 DECL dMULTIPLYADD0_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP0_333(A,+=,B,C) }
00191 DECL dMULTIPLYADD1_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP1_333(A,+=,B,C) }
00192 DECL dMULTIPLYADD2_333(TA *A, <span class="keyword">const</span> TB *B, <span class="keyword">const</span> TC *C) { dMULTIPLYOP2_333(A,+=,B,C) }
00193 
00194 <span class="preprocessor">#undef DECL</span>
00195 <span class="preprocessor"></span>
00196 <span class="preprocessor">#else</span>
00197 <span class="preprocessor"></span>
00198 <span class="preprocessor">#define dMULTIPLY0_331(A,B,C) dMULTIPLYOP0_331(A,=,B,C)</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY1_331(A,B,C) dMULTIPLYOP1_331(A,=,B,C)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY0_133(A,B,C) dMULTIPLYOP0_133(A,=,B,C)</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY0_333(A,B,C) dMULTIPLYOP0_333(A,=,B,C)</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY1_333(A,B,C) dMULTIPLYOP1_333(A,=,B,C)</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY2_333(A,B,C) dMULTIPLYOP2_333(A,=,B,C)</span>
00204 <span class="preprocessor"></span>
00205 <span class="preprocessor">#define dMULTIPLYADD0_331(A,B,C) dMULTIPLYOP0_331(A,+=,B,C)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYADD1_331(A,B,C) dMULTIPLYOP1_331(A,+=,B,C)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYADD0_133(A,B,C) dMULTIPLYOP0_133(A,+=,B,C)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYADD0_333(A,B,C) dMULTIPLYOP0_333(A,+=,B,C)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYADD1_333(A,B,C) dMULTIPLYOP1_333(A,+=,B,C)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLYADD2_333(A,B,C) dMULTIPLYOP2_333(A,+=,B,C)</span>
00211 <span class="preprocessor"></span>
00212 <span class="preprocessor">#endif</span>
00213 <span class="preprocessor"></span>
00214 
00215 <span class="preprocessor">#ifdef __cplusplus</span>
00216 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00217 <span class="preprocessor">#endif</span>
00218 <span class="preprocessor"></span>
00219 <span class="comment">/*</span>
00220 <span class="comment"> * normalize 3x1 and 4x1 vectors (i.e. scale them to unit length)</span>
00221 <span class="comment"> */</span>
00222 <span class="keywordtype">void</span> dNormalize3 (dVector3 a);
00223 <span class="keywordtype">void</span> dNormalize4 (dVector4 a);
00224 
00225 
00226 <span class="comment">/*</span>
00227 <span class="comment"> * given a unit length "normal" vector n, generate vectors p and q vectors</span>
00228 <span class="comment"> * that are an orthonormal basis for the plane space perpendicular to n.</span>
00229 <span class="comment"> * i.e. this makes p,q such that n,p,q are all perpendicular to each other.</span>
00230 <span class="comment"> * q will equal n x p. if n is not unit length then p will be unit length but</span>
00231 <span class="comment"> * q wont be.</span>
00232 <span class="comment"> */</span>
00233 
00234 <span class="keywordtype">void</span> dPlaneSpace (<span class="keyword">const</span> dVector3 n, dVector3 p, dVector3 q);
00235 
00236 <span class="preprocessor">#ifdef __cplusplus</span>
00237 <span class="preprocessor"></span>}
00238 <span class="preprocessor">#endif</span>
00239 <span class="preprocessor"></span>
00240 <span class="preprocessor">#endif</span>
</pre></div><br><br><small>Copyright (C) 2004 Jani Kajala. All rights reserved. Consult your license regarding permissions and restrictions.</small><br><br></body></html>
