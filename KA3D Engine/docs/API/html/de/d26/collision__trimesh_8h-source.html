<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Engine Core: collision_trimesh.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040824 -->
<div class="qindex"><a class="qindex" href="../../index.html">Main&nbsp;Page</a> | <a class="qindex" href="../../modules.html">Modules</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a></div>
<h1>collision_trimesh.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment"> *                                                                       *</span>
00003 <span class="comment"> * Open Dynamics Engine, Copyright (C) 2001-2003 Russell L. Smith.       *</span>
00004 <span class="comment"> * All rights reserved.  Email: russ@q12.org   Web: www.q12.org          *</span>
00005 <span class="comment"> *                                                                       *</span>
00006 <span class="comment"> * This library is free software; you can redistribute it and/or         *</span>
00007 <span class="comment"> * modify it under the terms of EITHER:                                  *</span>
00008 <span class="comment"> *   (1) The GNU Lesser General Public License as published by the Free  *</span>
00009 <span class="comment"> *       Software Foundation; either version 2.1 of the License, or (at  *</span>
00010 <span class="comment"> *       your option) any later version. The text of the GNU Lesser      *</span>
00011 <span class="comment"> *       General Public License is included with this library in the     *</span>
00012 <span class="comment"> *       file LICENSE.TXT.                                               *</span>
00013 <span class="comment"> *   (2) The BSD-style license that is included with this library in     *</span>
00014 <span class="comment"> *       the file LICENSE-BSD.TXT.                                       *</span>
00015 <span class="comment"> *                                                                       *</span>
00016 <span class="comment"> * This library is distributed in the hope that it will be useful,       *</span>
00017 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
00018 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *</span>
00019 <span class="comment"> * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *</span>
00020 <span class="comment"> *                                                                       *</span>
00021 <span class="comment"> *************************************************************************/</span>
00022 
00023 <span class="comment">/*</span>
00024 <span class="comment"> * TriMesh code by Erwin de Vries.</span>
00025 <span class="comment"> *</span>
00026 <span class="comment"> * Trimesh data.</span>
00027 <span class="comment"> * This is where the actual vertexdata (pointers), and BV tree is stored.</span>
00028 <span class="comment"> * Vertices should be single precision!</span>
00029 <span class="comment"> * This should be more sophisticated, so that the user can easyly implement</span>
00030 <span class="comment"> * another collision library, but this is a lot of work, and also costs some</span>
00031 <span class="comment"> * performance because some data has to be copied.</span>
00032 <span class="comment"> */</span>
00033 
00034 <span class="preprocessor">#ifndef _ODE_COLLISION_TRIMESH_H_</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define _ODE_COLLISION_TRIMESH_H_</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#ifdef __cplusplus</span>
00038 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
00041 <span class="comment">/*</span>
00042 <span class="comment"> * Data storage for triangle meshes.</span>
00043 <span class="comment"> */</span>
00044 <span class="keyword">struct </span>dxTriMeshData;
00045 <span class="keyword">typedef</span> <span class="keyword">struct </span>dxTriMeshData* dTriMeshDataID;
00046 
00047 <span class="comment">/*</span>
00048 <span class="comment"> * These dont make much sense now, but they will later when we add more</span>
00049 <span class="comment"> * features.</span>
00050 <span class="comment"> */</span>
00051 dTriMeshDataID dGeomTriMeshDataCreate();
00052 <span class="keywordtype">void</span> dGeomTriMeshDataDestroy(dTriMeshDataID g);
00053 
00054 <span class="keyword">enum</span> { TRIMESH_FACE_NORMALS, TRIMESH_LAST_TRANSFORMATION };
00055 <span class="keywordtype">void</span> dGeomTriMeshDataSet(dTriMeshDataID g, <span class="keywordtype">int</span> data_id, <span class="keywordtype">void</span>* data);
00056 
00057 
00058 <span class="comment">/*</span>
00059 <span class="comment"> * Build TriMesh data with single pricision used in vertex data .</span>
00060 <span class="comment"> */</span>
00061 <span class="keywordtype">void</span> dGeomTriMeshDataBuildSingle(dTriMeshDataID g,
00062                                  <span class="keyword">const</span> <span class="keywordtype">void</span>* Vertices, <span class="keywordtype">int</span> VertexStride, <span class="keywordtype">int</span> VertexCount, 
00063                                  <span class="keyword">const</span> <span class="keywordtype">void</span>* Indices, <span class="keywordtype">int</span> IndexCount, <span class="keywordtype">int</span> TriStride);
00064 <span class="comment">/* same again with a normals array (used as trimesh-trimesh optimization) */</span>
00065 <span class="keywordtype">void</span> dGeomTriMeshDataBuildSingle1(dTriMeshDataID g,
00066                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Vertices, <span class="keywordtype">int</span> VertexStride, <span class="keywordtype">int</span> VertexCount, 
00067                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Indices, <span class="keywordtype">int</span> IndexCount, <span class="keywordtype">int</span> TriStride,
00068                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Normals);
00069 <span class="comment">/*</span>
00070 <span class="comment">* Build TriMesh data with double pricision used in vertex data .</span>
00071 <span class="comment">*/</span>
00072 <span class="keywordtype">void</span> dGeomTriMeshDataBuildDouble(dTriMeshDataID g, 
00073                                  <span class="keyword">const</span> <span class="keywordtype">void</span>* Vertices,  <span class="keywordtype">int</span> VertexStride, <span class="keywordtype">int</span> VertexCount, 
00074                                  <span class="keyword">const</span> <span class="keywordtype">void</span>* Indices, <span class="keywordtype">int</span> IndexCount, <span class="keywordtype">int</span> TriStride);
00075 <span class="comment">/* same again with a normals array (used as trimesh-trimesh optimization) */</span>
00076 <span class="keywordtype">void</span> dGeomTriMeshDataBuildDouble1(dTriMeshDataID g, 
00077                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Vertices,  <span class="keywordtype">int</span> VertexStride, <span class="keywordtype">int</span> VertexCount, 
00078                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Indices, <span class="keywordtype">int</span> IndexCount, <span class="keywordtype">int</span> TriStride,
00079                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* Normals);
00080 
00081 <span class="comment">/*</span>
00082 <span class="comment"> * Simple build. Single/double precision based on dSINGLE/dDOUBLE!</span>
00083 <span class="comment"> */</span>
00084 <span class="keywordtype">void</span> dGeomTriMeshDataBuildSimple(dTriMeshDataID g,
00085                                  <span class="keyword">const</span> dReal* Vertices, <span class="keywordtype">int</span> VertexCount,
00086                                  <span class="keyword">const</span> <span class="keywordtype">int</span>* Indices, <span class="keywordtype">int</span> IndexCount);
00087 <span class="comment">/* same again with a normals array (used as trimesh-trimesh optimization) */</span>
00088 <span class="keywordtype">void</span> dGeomTriMeshDataBuildSimple1(dTriMeshDataID g,
00089                                   <span class="keyword">const</span> dReal* Vertices, <span class="keywordtype">int</span> VertexCount,
00090                                   <span class="keyword">const</span> <span class="keywordtype">int</span>* Indices, <span class="keywordtype">int</span> IndexCount,
00091                                   <span class="keyword">const</span> <span class="keywordtype">int</span>* Normals);
00092 <span class="comment">/*</span>
00093 <span class="comment"> * Per triangle callback. Allows the user to say if he wants a collision with</span>
00094 <span class="comment"> * a particular triangle.</span>
00095 <span class="comment"> */</span>
00096 <span class="keyword">typedef</span> <span class="keywordtype">int</span> dTriCallback(dGeomID TriMesh, dGeomID RefObject, <span class="keywordtype">int</span> TriangleIndex);
00097 <span class="keywordtype">void</span> dGeomTriMeshSetCallback(dGeomID g, dTriCallback* Callback);
00098 dTriCallback* dGeomTriMeshGetCallback(dGeomID g);
00099 
00100 <span class="comment">/*</span>
00101 <span class="comment"> * Per object callback. Allows the user to get the list of triangles in 1</span>
00102 <span class="comment"> * shot. Maybe we should remove this one.</span>
00103 <span class="comment"> */</span>
00104 <span class="keyword">typedef</span> <span class="keywordtype">void</span> dTriArrayCallback(dGeomID TriMesh, dGeomID RefObject, <span class="keyword">const</span> <span class="keywordtype">int</span>* TriIndices, <span class="keywordtype">int</span> TriCount);
00105 <span class="keywordtype">void</span> dGeomTriMeshSetArrayCallback(dGeomID g, dTriArrayCallback* ArrayCallback);
00106 dTriArrayCallback* dGeomTriMeshGetArrayCallback(dGeomID g);
00107 
00108 <span class="comment">/*</span>
00109 <span class="comment"> * Ray callback.</span>
00110 <span class="comment"> * Allows the user to say if a ray collides with a triangle on barycentric</span>
00111 <span class="comment"> * coords. The user can for example sample a texture with alpha transparency</span>
00112 <span class="comment"> * to determine if a collision should occur.</span>
00113 <span class="comment"> */</span>
00114 <span class="keyword">typedef</span> <span class="keywordtype">int</span> dTriRayCallback(dGeomID TriMesh, dGeomID Ray, <span class="keywordtype">int</span> TriangleIndex, dReal u, dReal v);
00115 <span class="keywordtype">void</span> dGeomTriMeshSetRayCallback(dGeomID g, dTriRayCallback* Callback);
00116 dTriRayCallback* dGeomTriMeshGetRayCallback(dGeomID g);
00117 
00118 <span class="comment">/*</span>
00119 <span class="comment"> * Trimesh class</span>
00120 <span class="comment"> * Construction. Callbacks are optional.</span>
00121 <span class="comment"> */</span>
00122 dGeomID dCreateTriMesh(dSpaceID space, dTriMeshDataID Data, dTriCallback* Callback, dTriArrayCallback* ArrayCallback, dTriRayCallback* RayCallback);
00123 
00124 <span class="keywordtype">void</span> dGeomTriMeshSetData(dGeomID g, dTriMeshDataID Data);
00125 
00126 dTriMeshDataID dGeomTriMeshGetData(dGeomID g);
00127 
00128 <span class="keyword">namespace </span>Opcode {
00129     <span class="keyword">class </span>Model;}
00130 
00131 Opcode::Model* dGeomTriMeshGetOpcodeModel(dGeomID g);
00132 
00133 <span class="comment">// enable/disable/check temporal coherence</span>
00134 <span class="keywordtype">void</span> dGeomTriMeshEnableTC(dGeomID g, <span class="keywordtype">int</span> geomClass, <span class="keywordtype">int</span> enable);
00135 <span class="keywordtype">int</span> dGeomTriMeshIsTCEnabled(dGeomID g, <span class="keywordtype">int</span> geomClass);
00136 
00137 <span class="comment">/*</span>
00138 <span class="comment"> * Clears the internal temporal coherence caches. When a geom has its</span>
00139 <span class="comment"> * collision checked with a trimesh once, data is stored inside the trimesh.</span>
00140 <span class="comment"> * With large worlds with lots of seperate objects this list could get huge.</span>
00141 <span class="comment"> * We should be able to do this automagically.</span>
00142 <span class="comment"> */</span>
00143 <span class="keywordtype">void</span> dGeomTriMeshClearTCCache(dGeomID g);
00144 
00145 
00146 <span class="comment">/*</span>
00147 <span class="comment"> * returns the TriMeshDataID</span>
00148 <span class="comment"> */</span>
00149 dTriMeshDataID dGeomTriMeshGetTriMeshDataID(dGeomID g);
00150 
00151 <span class="comment">/*</span>
00152 <span class="comment"> * Gets a triangle.</span>
00153 <span class="comment"> */</span>
00154 <span class="keywordtype">void</span> dGeomTriMeshGetTriangle(dGeomID g, <span class="keywordtype">int</span> Index, dVector3* v0, dVector3* v1, dVector3* v2);
00155 
00156 <span class="comment">/*</span>
00157 <span class="comment"> * Gets the point on the requested triangle and the given barycentric</span>
00158 <span class="comment"> * coordinates.</span>
00159 <span class="comment"> */</span>
00160 <span class="keywordtype">void</span> dGeomTriMeshGetPoint(dGeomID g, <span class="keywordtype">int</span> Index, dReal u, dReal v, dVector3 Out);
00161 
00162 <span class="comment">/*</span>
00163 <span class="comment"></span>
00164 <span class="comment">This is how the strided data works:</span>
00165 <span class="comment"></span>
00166 <span class="comment">struct StridedVertex{</span>
00167 <span class="comment">    dVector3 Vertex;</span>
00168 <span class="comment">    // Userdata</span>
00169 <span class="comment">};</span>
00170 <span class="comment">int VertexStride = sizeof(StridedVertex);</span>
00171 <span class="comment"></span>
00172 <span class="comment">struct StridedTri{</span>
00173 <span class="comment">    int Indices[3];</span>
00174 <span class="comment">    // Userdata</span>
00175 <span class="comment">};</span>
00176 <span class="comment">int TriStride = sizeof(StridedTri);</span>
00177 <span class="comment"></span>
00178 <span class="comment">*/</span>
00179 
00180 
00181 
00182 
00183 <span class="preprocessor">#ifdef __cplusplus</span>
00184 <span class="preprocessor"></span>}
00185 <span class="preprocessor">#endif</span>
00186 <span class="preprocessor"></span>
00187 <span class="preprocessor">#endif  </span><span class="comment">/* _ODE_COLLISION_TRIMESH_H_ */</span>
00188 
</pre></div><br><br><small>Copyright (C) 2004 Jani Kajala. All rights reserved. Consult your license regarding permissions and restrictions.</small><br><br></body></html>
